<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>AQS之AQS分析 - 凌风的小窝</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="凌风的小窝"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="凌风的小窝"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="接下来的这篇文章将详细分析AQS，AQS全称是AbstractQueuedSynchronizer，翻译过来是抽象队列同步器，也即AQS是一个基于队列实现的抽象同步器 AQS封装了获取锁，释放锁等操作，同时暴露一些try开头的方法交给子类来实现，通过继承AQS可以非常方便地实现一个线程安全的并发同步器，在java.util.concurrent包中的大多数高层次同步器，如CountdownLatc"><meta property="og:type" content="blog"><meta property="og:title" content="AQS之AQS分析"><meta property="og:url" content="https://www.xuhuanfeng.cn/2019/11/20/AQS%E4%B9%8BAQS%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="凌风的小窝"><meta property="og:description" content="接下来的这篇文章将详细分析AQS，AQS全称是AbstractQueuedSynchronizer，翻译过来是抽象队列同步器，也即AQS是一个基于队列实现的抽象同步器 AQS封装了获取锁，释放锁等操作，同时暴露一些try开头的方法交给子类来实现，通过继承AQS可以非常方便地实现一个线程安全的并发同步器，在java.util.concurrent包中的大多数高层次同步器，如CountdownLatc"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092736.png"><meta property="og:image" content="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092815.png"><meta property="og:image" content="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092842.png"><meta property="article:published_time" content="2019-11-20T08:01:29.000Z"><meta property="article:modified_time" content="2021-04-28T05:43:22.287Z"><meta property="article:author" content="大黄蜂"><meta property="article:tag" content="Java"><meta property="article:tag" content="AQS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092736.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.xuhuanfeng.cn/2019/11/20/AQS%E4%B9%8BAQS%E5%88%86%E6%9E%90/"},"headline":"凌风的小窝","image":["https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092736.png","https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092815.png","https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092842.png"],"datePublished":"2019-11-20T08:01:29.000Z","dateModified":"2021-04-28T05:43:22.287Z","author":{"@type":"Person","name":"大黄蜂"},"description":"接下来的这篇文章将详细分析AQS，AQS全称是AbstractQueuedSynchronizer，翻译过来是抽象队列同步器，也即AQS是一个基于队列实现的抽象同步器 AQS封装了获取锁，释放锁等操作，同时暴露一些try开头的方法交给子类来实现，通过继承AQS可以非常方便地实现一个线程安全的并发同步器，在java.util.concurrent包中的大多数高层次同步器，如CountdownLatc"}</script><link rel="canonical" href="https://www.xuhuanfeng.cn/2019/11/20/AQS%E4%B9%8BAQS%E5%88%86%E6%9E%90/"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">凌风的小窝</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xuhuanfeng"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-20T08:01:29.000Z" title="2019/11/20 下午4:01:29">2019-11-20</time>发表</span><span class="level-item"><time dateTime="2021-04-28T05:43:22.287Z" title="2021/4/28 下午1:43:22">2021-04-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/Concurrent/">Concurrent</a></span><span class="level-item">1 小时读完 (大约10598个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">AQS之AQS分析</h1><div class="content"><p>接下来的这篇文章将详细分析AQS，AQS全称是AbstractQueuedSynchronizer，翻译过来是抽象队列同步器，也即AQS是一个基于队列实现的抽象同步器</p>
<p>AQS封装了获取锁，释放锁等操作，同时暴露一些try开头的方法交给子类来实现，通过继承AQS可以非常方便地实现一个线程安全的并发同步器，在<code>java.util.concurrent</code>包中的大多数高层次同步器，如<code>CountdownLatch</code>、<code>ReentrantLock</code>等都是通过AQS实现的</p>
<p>常用的基于AQS高层次同步器有如下几个</p>
<ul>
<li>CountdownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>ReentrantLock</li>
</ul>
<p>这篇文章只分析AQS提供的通用逻辑实现，分析完AQS之后，后面再用新的篇章分析基于AQS的同步工具的具体实现细节</p>
<blockquote>
<p>本文参考自<a target="_blank" rel="noopener" href="https://javadoop.com/">javadoop</a>的</p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">一行一行源码分析清楚 AbstractQueuedSynchronizer (二)</a></p>
<p>非常感谢大神无私地分享</p>
</blockquote>
<span id="more"></span>

<h1 id="AQS之AQS分析"><a href="#AQS之AQS分析" class="headerlink" title="AQS之AQS分析"></a>AQS之AQS分析</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在具体分析AQS之前，有几个核心概念需要先弄清楚，这些概念是看懂接下来内容必不可少的</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一个基础的线性数据结构，节点之前通过”指针”链接起来，从而构成一个完整的链，<code>java.util.LinkedList</code>就是一个非常典型的链表的实现</p>
<p>链表根据实现细节的不同，有三种比较典型的链表</p>
<ul>
<li>单向链表，节点通过单向指针链接起来，每个节点只能访问其后面的节点</li>
<li>双向链表，每个节点通过前向指针，后向指针分别链接前节点、后节点，每个节点可以访问其前后节点</li>
<li>循环链表，链表收尾相连，构成一个环，有两种典型实现<ul>
<li>单向循环链表</li>
<li>双向循环链表</li>
</ul>
</li>
</ul>
<p>AQS中获取不到锁的排队就是通过一个双向链表来实现，该队列也称为等待队列(同步队列)</p>
<p>同时也通过内部类<code>ConditionObject</code>，来实现<code>Condition</code>的语义，在某个条件上等待的语义就是通过一个单向链表来实现，该队列也称为条件队列</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁，这个概念并不陌生，在并发环境下，对于临界区的访问，为了避免并发操作对数据带来不一致性(也称为竞态条件)，通常需要先获取锁再执行对应操作</p>
<p>根据同时可以被持有对象的不同，锁可以分为两种</p>
<ul>
<li>独占锁，也称为X锁，顾名思义，同时只能被一个线程持有，只有加锁的线程才能解开锁</li>
<li>共享锁，也称为S锁，允许同时多个线程持有(同时加锁或者解锁都是可以)</li>
</ul>
<p>根据是否可被中断，锁可以分为两种</p>
<ul>
<li>可中断锁，顾名思义，收到中断信号，并且会处理中断信号，在Java中通常表现为抛出中断异常<code>InterruptedException</code></li>
<li>不可中断锁，发生中断异常时，仅记录中断信号而不会抛出中断异常</li>
</ul>
<p>根据获取锁的时机不同，锁可以分为两种</p>
<ul>
<li>抢占锁，也称为非公平锁，释放锁的那一刻，允许新来的线程参与锁的抢占</li>
<li>不可抢占锁，也称为公平锁，按照先来后到的顺序分配锁</li>
</ul>
<p>根据锁的策略，可以分为两种</p>
<ul>
<li>乐观锁，认为竞争本身很小，所以大部分情况下是不需要获取锁来访问临界区</li>
<li>悲观锁，认为竞争大，每次访问临界区都需要获取锁</li>
</ul>
<p>上面的几种分类是常见的锁的分类，这些分类之间是可以相互组合的，如不可中断独占锁，可中断共享锁等</p>
<p>在AQS中，提供了独占锁和共享锁的实现，同时，提供一个方法用于实现公平锁、非公平锁</p>
<h3 id="无锁化"><a href="#无锁化" class="headerlink" title="无锁化"></a>无锁化</h3><p>在旧版的JDK中，提供了基于监视器的<code>synchronized</code>关键字，用于作为锁的实现，该锁是自动获取以及释放，有时候也称为对象锁，因为锁的目标就是某个对象</p>
<p>使用锁的好处的使用方便，直观，但也有比较明显的缺点</p>
<ol>
<li>通常获取锁的时候，如果无法获取到锁，则线程本身会被阻塞，等到锁重新释放的时候，才会重新尝试获取锁，当并发比较大的时候，对于锁的竞争会非常激烈，容易影响性能</li>
<li>在一些场景中，临界区本身非常小，对于临界区的操作时间比获取锁、释放锁两个操作加起来的时间还小，也就容易造成锁本身带来的消耗大于实际工作的时间</li>
</ol>
<p>于是，无锁化的概念逐渐提出，无锁化，顾名思义，对临界区的操作本身不再通过加锁的形式来访问，有时候，这种形式也称为乐观锁，目前采用得比较多的就是通过CAS来实现无锁化操作，CAS本身需要CPU提供支持，关于Java中的CAS实现，可以大致参考下之前的文章：<a href="https://www.xuhuanfeng.cn/2019/10/06/AtomicXXX%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/#more">AtomicXXX使用及分析</a></p>
<p>在AQS中，对于临界区(锁状态、链表节点改变等)的操作，都是通过CAS来实现的</p>
<h3 id="条件等待"><a href="#条件等待" class="headerlink" title="条件等待"></a>条件等待</h3><p>条件等待在编程中非常常见，某一个线程需要某些资源，而这些资源目前还没有准备完成，此时线程就需要等待该资源准备完成之后再运行，在等待期间，线程需要挂起，这个过程也称为”条件等待”。</p>
<p>等待某个条件发生，如常见的生产者消费者模型中，当缓冲区满了的时候，生产者需要等待缓冲区有空间，当缓冲区空的时候，消费者需要等待缓冲区有内容</p>
<p>在Java中，每一个对象都可以作为一个条件，多个线程可以在该对象上进行等待，如常见的<code>obj.wait()</code>，在进行条件等待的时候，需要先获取该对象锁，否则会抛出监视器异常，执行wait操作之后，线程会被挂起，同时，线程持有的锁会被释放；当被其他线程唤醒，即<code>notify()</code>的时候，线程会被唤醒，重新获取锁，然后继续执行(注意，此时条件不一定满足，因为从条件发生到线程获取到CPU执行存在时间差，可能线程继续执行的时候，条件又不满足了，所以一般是将条件等待放在循环中，唤醒之后重新检查一下是否条件满足)</p>
<h2 id="AQS核心内容"><a href="#AQS核心内容" class="headerlink" title="AQS核心内容"></a>AQS核心内容</h2><h3 id="Node结构"><a href="#Node结构" class="headerlink" title="Node结构"></a>Node结构</h3><p>Node是AQS的一个内部类，该类本身所包含的属性不多，却是整个AQS的核心，有如下几个属性</p>
<ul>
<li>waitStatus，等待状态</li>
<li>thread，节点对应的线程</li>
<li>next，指向<strong>等待队列下一个节点</strong></li>
<li>prev，指向<strong>等待队列前一个节点</strong></li>
<li>nextWaiter，指向<strong>条件队列下一个节点</strong></li>
</ul>
<p>其中的waitStatus是比较复杂的，用于标志当前节点所处的状态，有以下几个值</p>
<ul>
<li>CANCELLED：1，表示线程取消等待</li>
<li>0，默认值</li>
<li>SIGNAL：-1，表示<strong>下一个节点</strong>需要被唤醒</li>
<li>CONDITION：-2，表示当前节点处于等待条件发生</li>
<li>PROPAGATE：-3，表示下一个节点等待共享锁的线程需要被无条件通知</li>
</ul>
<p>nextWaiter是另外一个比较有趣的字段，前面提到了，AQS支持条件等待，当多个线程在同一个条件上等待时，显然，也是需要将其合理的组织起来</p>
<p>Node中通过类型的Node的nextWaiter将其串联起来，其值有两种</p>
<ul>
<li>当处于共享模式时，节点的值均为<code>SHARE</code></li>
<li>当处于排他模式时，为等待同样条件的节点(默认为null，表示没有)</li>
</ul>
<p>当节点处于等待获取锁时，等待队列如下图所示</p>
<p><img src="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092736.png" alt="等待队列.png"></p>
<p>当节点处于等待某个条件时，条件队列如下所示</p>
<p><img src="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092815.png" alt="条件队列.png"></p>
<h3 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h3><p>AQS的实现细节非常复杂，各种情况错综复杂，考虑地非常详细，但是，AQS的结构本身非常简单，由一个head一个tail构成等待队列，一个state代表锁状态，一个exclusiveOwnerThread代表独占锁持有线程</p>
<p>state就是一个整数，0表示当前锁没有被占有，大于0表示重入，为了保证可见性，同时被声明为<code>volatile</code></p>
<p>exclusiveOwnerThread代表的是当前占据独占锁的线程，该属性继承于AbstractOwnableSynchronizer</p>
<p>AQS的完整结构如下</p>
<p><img src="https://raw.githubusercontent.com/xuhuanfeng/images/master/blog-images20201206092842.png" alt="AQS.png"></p>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>前面提到了，AQS提供的核心功能其实就是获取锁以及释放锁这两个操作，对于AQS的理解，关键也在于这两个操作，根据锁类型的不同，AQS提供了独占锁与共享锁两种不同类型的操作，接下来详细分析每一个操作</p>
<h4 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h4><p>AQS中，获取锁的操作通过acquire开头的一些方法完成的，根据是否可被中断，分为两种：可中断以及不可中断，关于这两者前面已经介绍了，这里就不展开，直接分析AQS的实现</p>
<h5 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>acquire</code>方法是一个模板方法，留下了<code>tryAcquire</code>交由子类实现，也即子类根据实现的不同，决定什么时候能够获取成功(返回true)，什么时候获取失败(返回false)</p>
<p>由于获取成不成功是由子类决定的，并且不同的工具的含义也不同，这里我们只重点看下获取失败的操作</p>
<p>根据独占锁的语义，一把锁同时只能被一个线程持有，在持有锁期间，其他线程尝试获取锁，都应该被阻塞或者挂起，结合上面的前面等待队列的图示，不难猜出，获取失败之后的大致流程就是将当前线程包装成链表节点，然后添加到链表中，最后挂起自己，等待唤醒</p>
<blockquote>
<p>addWaiter操作</p>
</blockquote>
<p>首先是addWaiter操作，在AQS中，等待队列的一个节点也称为一个waiter，那么，这个方法就很显然了，将线程包装成一个waiter，然后添加到等待队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数mode代表的含义是当前线程的等待类型，这里是独占锁，那就是EXCLUSIVE啦</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 初始情况下，head=tail=null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pred != null说明等待队列初始化完成了</span></span><br><span class="line">    <span class="comment">// 那就尝试将自己挂在队列尾部，成为新的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的prev指针指向原来的tail(这一步线程安全)</span></span><br><span class="line">        node.prev = pred; <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 通过cas将原来的tail设置为自己</span></span><br><span class="line">        <span class="comment">// 注意，这里是存在并发情况的，如果有两个线程同时将自己设置为尾部</span></span><br><span class="line">        <span class="comment">// 那么存在一个被另一个覆盖的情况，所以需要通过CAS来保证只有一个成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="comment">// 如果cas成功，则将原尾部的next指向自己，使自己成为新的尾部</span></span><br><span class="line">            pred.next = node; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上面的1、2、3三个步骤不能变换顺序，否则会出现数据错乱</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果到了这里，有两种情况</span></span><br><span class="line">    <span class="comment">// 1、队列未初始化</span></span><br><span class="line">    <span class="comment">// 2、CAS失败，表明同一时刻有另一个线程抢先成为尾节点了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 那应该怎么办呢？</span></span><br><span class="line">    <span class="comment">// 很显然，入队是必须的，那就只能一直尝试入队，直到成功为止了</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>enq操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该操作意图很简单，一直尝试入队，直到成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 此时队列尚未初始化，那就初始化一下咯</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意，同样存在并发，所以需要通过CAS</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">            <span class="comment">// 可以看到，初始化本身是延迟到有节点入队的时候才进行的</span></span><br><span class="line">            <span class="comment">// 初始化也很简单，就是创建一个空节点作为头部，同时，初始化尾部</span></span><br><span class="line">            <span class="comment">// 注意，初始化之后没有return，所以重新循环会进入到else中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这一步就跟addWaiter里面的操作一样啦</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，完成了三个操作</p>
<ol>
<li>尝试直接获取锁，如果可以，那就获取到，接着按照线程的处理逻辑走</li>
<li>如果获取失败，那将自己挂到等待队列尾部<ol>
<li>如果队列未初始化，那就先初始化一下</li>
<li>如果挂到队列尾部失败，那就一直挂，直到成功，失败的原因只有一个，被其他人抢了，那最后一定会入队成功的，当没有其他人抢占入队的时候，自己就能入队了</li>
</ol>
</li>
</ol>
<p>经过前面的几个步骤，此时线程已经入队成功了，此时线程面临着两个选择</p>
<ul>
<li>如果入队完了之后，刚刚好排到自己去运行了，那就不用挂起了，直接去执行就完事了</li>
<li>另一种就是，还没轮到自己去运行，那就老老实实挂起了</li>
</ul>
<blockquote>
<p>acquireQueued</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回true表示挂起过程发生中断，false表示没有</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前一个节点是head，并且能拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将自己设置为头结点，直接返回</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到了这里，说明要么不是头结点，要么就抢不过别人</span></span><br><span class="line">            <span class="comment">// 那就看下是否要挂起了，要就挂起了</span></span><br><span class="line">            <span class="comment">//  当shouldParkAfterFailedAcquire返回false时，就接着循环</span></span><br><span class="line">            <span class="comment">//   返回true，就进入park了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// park返回true表明需要中断，记录下中断信号</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里，正常走流程是不会到这里的</span></span><br><span class="line">        <span class="comment">// 如果走到这里，说明是抛出异常了，那就取消了</span></span><br><span class="line">        <span class="comment">// 毕竟执行过程出错了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shouldParkAfterFailedAcquire</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前一个节点的ws为SIGNAL，说明当前节点已经向前节点</span></span><br><span class="line">    <span class="comment">// 告知自己需要被唤醒了，那接着挂起吧</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果前一个节点的ws&gt;0，说明前一个节点取消等待了</span></span><br><span class="line">    <span class="comment">// 那只能重新找一个新的前向节点了</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到了这里说明此时ws=0或者-3</span></span><br><span class="line">        <span class="comment">// 那重新修正一下，修改为SIGNAL(-1)</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刚刚修改完状态或者调整父节点，本次先不挂起</span></span><br><span class="line">    <span class="comment">// 下一波再试试看能不能直接运行，实在不行再挂起，毕竟挂起的代价还是蛮高的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>parkAndCheckInterrupt</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到这里就挂起了</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 到这里线程就醒来</span></span><br><span class="line">    <span class="comment">//  醒来的原因有两个</span></span><br><span class="line">    <span class="comment">//   1. 收到中断信号</span></span><br><span class="line">    <span class="comment">//   2. 其他线程执行unpark操作(也就是signal啦)</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cancelAcquire</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前面也有节点取消了，那顺便清理一下吧</span></span><br><span class="line">    <span class="comment">// 毕竟取消了就没有排队的意义了</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志为取消状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到了这里，当前节点前面的取消了排队的节点就已经被清理了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果node为尾节点，那将pred设置为新的tail</span></span><br><span class="line">    <span class="comment">// 由于此时对tail操作，所以存在竞态(可能此时有人同时入队)</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 将pred的next设置为null，也就是tail的next清空啦</span></span><br><span class="line">        <span class="comment">// 原来是引用node嘛</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="comment">// 如果进入这里，说明取消排队的节点位于队列中间，也就是前后都有人</span></span><br><span class="line">        <span class="comment">// 如果位于中间，那就得看下需不需要通知后面的节点了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// if的条件很严苛，只有同时满足三个，才会进入</span></span><br><span class="line">        <span class="comment">//  进入的目的就是把node后面的节点挂在起来，毕竟node本身已经取消了</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 1. node的前节点不是head</span></span><br><span class="line">            pred != head &amp;&amp;</span><br><span class="line">            <span class="comment">// 2. 前节点的状态值=-1或者&lt;=0并且修改为-1成功</span></span><br><span class="line">            <span class="comment">//   这一点是避免执行到if的时候，pred自己也取消了(取消的waitStatus是-1)</span></span><br><span class="line">            <span class="comment">//   </span></span><br><span class="line">             ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            <span class="comment">// 3. pred存在线程，这个应该只是额外检查，大部分情况下都是存在的</span></span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">// 将pred的next设置为next，也就是跳过了node了</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不满足上面情况的，那就直接唤醒后面的节点了</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unparkSuccessor</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将node状态改为0，表明即将唤醒后面的节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line"> 	<span class="comment">// 如果next节点为空或者已经取消排队</span></span><br><span class="line">    <span class="comment">// 那就从后往前找了(这种情况还是很少的，大部分情况都是正常的节点)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为什么需要从后往前呢</span></span><br><span class="line">        <span class="comment">//  当s为null时，很显然了，next链已经断开，只能从prev入手了</span></span><br><span class="line">        <span class="comment">// 如果已经取消排队了呢？</span></span><br><span class="line">        <span class="comment">// 回顾一下cancelAcquire的最后一行node.next = node</span></span><br><span class="line">        <span class="comment">// 此时next链(可能)也已经断开了</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，获取锁的完整过程就接近分析完毕了，重新回顾一下acquire方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 如果发送中断了，那就发送一个中断信号，毕竟之前的已经取消了</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h5><p>前面我们详细分析了acquire方法，该方法是不可中断的，从代码中也可以看到，当发生中断时只是记录下中断信号，然后重新等待获取锁</p>
<p>而可中断的获取锁的方式就不同了，当发生中断的时候，会直接抛出中断异常，从而结束当前的等待，具体看下面分析</p>
<blockquote>
<p>acquireInterruptibly</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查一下是否需要中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 同样的，先试一下，如果失败，再接着走</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doAcquireInterruptibly</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 包装成Node</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 下面的处理逻辑基本同acquireQueued，只是现在响应中断了</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 跟前面一样，拿到锁就结束</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查是否需要挂起，注意这里发生中断之后，直接就抛出</span></span><br><span class="line">            <span class="comment">// 中断异常了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前面的铺垫，分析可中断的情况就简单得多了，从代码中也可以看出，不可中断和可中断的区别就在于，可中断在发生中断之后，就取消排队(注意是在finally里面，一定会执行的)，然后抛出异常了</p>
<p>到这里，获取锁的全部内容就分析完毕了，如果没怎么看懂的话，再结合源码多看几次就大致能看懂了</p>
<h4 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h4><p>共享锁的相对于独占锁来说，支持同时多个线程持有锁，这也就使得其稍微有点复杂，接下来详细分析共享锁，同样的，共享锁支持不可中断以及可中断两种形式</p>
<h5 id="不可中断-1"><a href="#不可中断-1" class="headerlink" title="不可中断"></a>不可中断</h5><blockquote>
<p>acquireShared</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同样的，先试下，不成功的话，就接着往下走</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tryAcquireShared方法返回类型是一个int，有三种含义</p>
<ul>
<li>负数，表示获取失败</li>
<li>0，以独占形式获取</li>
<li>正数，获取成功</li>
</ul>
</blockquote>
<blockquote>
<p>doAcquireShared</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包装成worker，注意模式是SHARE</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 先尝试一下，说不定能成功呢</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 到这里说明获取成功了</span></span><br><span class="line">                    <span class="comment">// 设置头部并且尝试唤醒下一个节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果有中断，那传递一下中断信号</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    </span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这一部分就跟获取独占锁处理逻辑一样了</span></span><br><span class="line">            <span class="comment">// 检查是否需要挂起，需要就挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 这里需要特别注意</span></span><br><span class="line">            <span class="comment">// 唤醒之后，被唤醒的节点的前一个节点一般就是head，所以，会接着唤醒后续节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 同样的，失败就取消排队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的方法可以看到，共享锁的获取方式跟独占锁还是挺接近的，区别在于共享模式中，节点获取到锁之后，会传递信号，具体分析如下</p>
<blockquote>
<p>setHeadAndPropagate</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 注意这个操作，将自己设置为头节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 如果propagate &gt; 0或者原有的head的状态是&lt;0</span></span><br><span class="line">    <span class="comment">// 或者新的head的状态是&lt;0</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果s是共享模式</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 唤醒下一个节点，此时，下一个节点的prev就是当前节点</span></span><br><span class="line">            <span class="comment">// 而前面已经将当前节点设置为head，所以，很大概率下个节点</span></span><br><span class="line">            <span class="comment">// 也会被唤醒(如果能拿到锁)</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doReleaseShared</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果head的状态为-1，则改为0，并且唤醒下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里失败的原因在于可能多个人同时修改head的状态</span></span><br><span class="line">                <span class="comment">// 比如当前线程以及唤醒当前线程的线程</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果head状态为0，则将其改为PROPAGATE</span></span><br><span class="line">            <span class="comment">// 这里就不是很理解，改成PROPAGATE的意义是什么???</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点没有发生变化，说明唤醒之后，后续节点</span></span><br><span class="line">        <span class="comment">// 还没有调度执行，说明此时任务还是比较繁重，那就退出</span></span><br><span class="line">        <span class="comment">// 当前线程唤醒其他线程的任务了</span></span><br><span class="line">        <span class="comment">// 这里还是不太明白？？？</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看到，在获取到锁之后，每个线程都会尝试唤醒下一个节点，而每个线程被唤醒之后，都会检查自己前面是否是头结点，能否获取到锁，如果都可以，就会继续唤醒接下来的线程</p>
<p>这是与独占模式最大的区别，共享模式下，一旦释放锁，会接着尝试唤醒等待队列中处于共享模式的其他节点，注意，是每个被唤醒节点都会这么做，这就相当于一个唤醒链了</p>
<h5 id="可中断-1"><a href="#可中断-1" class="headerlink" title="可中断"></a>可中断</h5><p>看完了独占锁的可中断模式，很容易就能猜到共享锁的可中断模式了</p>
<blockquote>
<p>acquireSharedInterruptibly</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查中断情况</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 拿不到锁，那就排队挂起</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doAcquireSharedInterruptibly</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">            	<span class="comment">// 其实就这里变化了，变成了直接抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>前面的获取锁部分，详细分析了获取锁的过程，有获取锁，自然就有释放锁了，锁的释放过程相对于获取锁来说，就简单地多了，毕竟释放锁本身并不需要进行同步，接下来详细分析释放锁的过程</p>
<p>同样的，独占锁和共享锁的释放过程是不同了，所以下面也是区分开两者进行分析</p>
<h4 id="释放独占锁"><a href="#释放独占锁" class="headerlink" title="释放独占锁"></a>释放独占锁</h4><p>独占锁的释放本身来说，比共享锁简单，因为能够释放独占锁，本身就意味着自己已经持有独占锁了，那一切的操作都是无需关注并发问题的</p>
<p>独占锁的释放主要包含两个流程</p>
<ol>
<li>释放自己占据的资源(即锁的状态)</li>
<li>唤醒后续节点</li>
</ol>
<blockquote>
<p>release</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放，释放成功就唤醒后续节点</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，<code>tryRelease</code>本身是一个空方法，由子类实现，关于如何使用，会在后续分析基于AQS的工具中具体分析到，这里先挖个坑</p>
<h4 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a>释放共享锁</h4><p>释放共享锁相对于独占锁来说，稍微有点复杂，但如果仔细看前面的获取共享锁部分，那其实释放锁的过程基本也就清楚了</p>
<blockquote>
<p>releaseShared</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放一下</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doReleaseShared</p>
</blockquote>
<p>这个方法是实际释放锁的操作，不过这里就不分析了，为啥？前面分析获取共享锁已经分析过了，如果忘记了，返回去看一下就可以了</p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>如果你看到这里，首先应该恭喜你，关于AQS的大部分内容基本已经分析完毕了，AQS中最最复杂的内容已经结束了，接下来分析的内容可以理解为AQS的扩展部分</p>
<p>在AQS中，提供了条件等待的语义实现，关于条件等待的基础概念，在前面核心概念部分稍微提到了，接下来将详细分析其具体语义及AQS的实现</p>
<h4 id="条件等待-1"><a href="#条件等待-1" class="headerlink" title="条件等待"></a>条件等待</h4><p>条件等待其实就是等待指定条件的发生，当线程在处理某个任务的之后，需要特定的资源/条件下才能接着进行，那么，线程就应该停止下来等待该条件的发生，当然，对于开发者而言，就需要对应的工具来实现该语义了</p>
<p>在JDK中，提供了最原始的支持，每一个Object对象本身就是一个条件队列，通过Object对象的<code>wait</code>方法就可以实现在该条件上进行等待，通过<code>notify</code>或者<code>notifyAll</code>就可以唤醒在该条件上等待的对象，同时，需要注意，操作这些方法时候，需要获取该条件的监视器锁</p>
<p>AQS之所以也提供条件等待的支持，就是原始的条件等待本身不够强大，具体表现为：一个Object对象有唯一一把监视器锁，唯一一个等待队列，但在实际使用过程中，却经常需要有同一把锁对应多个条件的情况，如，在操作缓冲区的时候，需要获取缓冲区的锁，然后进行操作(读/写)，此时，缓冲区满了以及缓冲区有空间，对应的是两个条件，但是对应的是操作缓冲区这把锁，通过原始的实现方法，就得通过两个锁来实现两个条件等待了，当条件越多的时候，需要的锁数量也就越多，锁越多，就越不好维护，万一一不小心忘记释放了呢</p>
<p>所以，在JDK1.5中，提出了<code>Condition</code>的概念，同时，通过AQS提供实现</p>
<p><code>Condition</code>的语义与原始的条件等待是一样的，但解决了原始条件等待存在的问题，对于<code>Condition</code>的操作，同样需要获取对应的锁，只是<code>Condition</code>不再依赖于监视器锁，而是通过自定义锁提供支持，如<code>ReentrantLock</code>，同一把锁可以支持一个到多个<code>Condition</code>，从而满足了在同一把锁上实现多个条件等待的需求</p>
<blockquote>
<p>Condition</p>
</blockquote>
<p>Condition接口提供的方法都非常清晰，简单看一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">locks</span>.<span class="title">Condition</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span>)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span>, TimeUnit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// 对应Object的nofity和notifyAll</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Condition</code>中的<code>await</code>对应的就是<code>Object</code>中的<code>wait</code>，<code>signal</code>对应<code>notify</code>，<code>signalAll</code>对应<code>notifyAll</code>，至于为什么不直接覆盖，应该是为了保留原始的语义，<code>Condition</code>本身也可以作为一个条件(一切均继承<code>Object</code>)</p>
<p>了解了AQS加锁的过程，大致也可以猜出来，等待条件发生的过程其实就是将等待的节点挂到指定的条件队列上，而条件的到达，其实就是对应的操作了</p>
<p>接下来详细分析AQS中<code>Condition</code>语义的实现，即<code>ConditionObject</code></p>
<h4 id="ConditionObject-1"><a href="#ConditionObject-1" class="headerlink" title="ConditionObject"></a>ConditionObject</h4><h5 id="ConditionObject结构"><a href="#ConditionObject结构" class="headerlink" title="ConditionObject结构"></a>ConditionObject结构</h5><p>ConditionObject也是AQS的内部类，包含的属性也是比较简单的</p>
<ul>
<li><code>firstWaiter</code></li>
<li><code>lastWaiter</code></li>
</ul>
<p>两个属性的类型都是<code>Node</code>，就是上面已经分析过的那个<code>Node</code>，看到这里，大致上就可以猜出来了，AQS中的<code>Conditoin</code>实现其实就是一个链表，将等待的节点挂到该链表上而已</p>
<h5 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h5><p>等待的语义就是说，当前这个条件不满足接着运行下去的需求，那么需要挂起等待其条件的发生，当然，由于自己已经挂起了，那么唤醒自然就是由其他人来操作了</p>
<p>当然，等待本身也是支持不可中断已经可中断的，从前面分析获取锁的过程大致已经可以得知，两者差异不大，这里我们就放一起分析了，不单独开一个小节</p>
<blockquote>
<p>await</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将自己添加到条件队列中(先看下面对该方法的分析，再接着往下走)</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放自己占据的锁，必须先获取锁才能进行等待(先看下面对该方法的分析，再接着往下走)</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里就说明锁释放成功了，那接下来就准备挂起，等待条件发生了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查看自己是否在同步队列(等待队列)</span></span><br><span class="line">    <span class="comment">//  如果不在，那就说明自己还没有被唤醒，此时醒来是意外</span></span><br><span class="line">    <span class="comment">//  为什么呢？</span></span><br><span class="line">    <span class="comment">// 联想一下前面获取锁的操作，要执行条件等待，必须先获取锁，此时自己必定是队头</span></span><br><span class="line">    <span class="comment">// 同时，等待之前，必须释放锁，此时会唤醒等待队列的后续节点，那么，也就意味着自己已经</span></span><br><span class="line">    <span class="comment">// 离开了等待队列，在条件队列中了</span></span><br><span class="line">    <span class="comment">// 如果又回到了等待队列，那么就说明情况发生了，自己被重新移动回等待队列中(参加唤醒操作)</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 检查是否在等待过程中出现中断(先看下面对该方法的分析，再接着往下走)</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接滑动到checkInterruptWhileWaiting的分析之后，这里太庞大了，放在后头分析</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>addConditionWaiter</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将等待节点添加到条件队列中，该方法可以说是条件等待的核心了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果有节点取消等待了，那就先移除咯</span></span><br><span class="line">    <span class="comment">// 取消了就没必要等待了</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 比较直观，将自己挂到队尾就行了</span></span><br><span class="line">    <span class="comment">// 这里之所以不需要通过CAS，是因为此时已经持有锁了，不存在并发情况</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>unlinkCancelledWaiters</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将取消排队的节点移除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从头到尾扫一遍，如果取消了，就将其移除</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">// 断开t</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// trail为null说明中间没有出现跳点，即(取消-不取消-取消的情况)</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="comment">// 跳过取消的节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果节点依旧在等待，trail往后移动就行</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fullyRelease</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全释放锁，毕竟有重入的情况存在</span></span><br><span class="line"><span class="comment">// 返回当前锁的情况，后续重新获取的时候需要使用到</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前锁状态(包含重入的情况)</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 如果能够释放成功，那就返回了</span></span><br><span class="line">        <span class="comment">// release的行为取决了tryRelease</span></span><br><span class="line">        <span class="comment">// 正常情况来说，释放都是成功的，毕竟是自己持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        <span class="comment">// 如果释放失败，那就抛出监视器异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点失败，将当前节点状态调整为取消，后面会被移除</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>isOnSyncQueue</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果此时状态还是等待(见signal分析)，或者前面没有节点</span></span><br><span class="line">    <span class="comment">// 说明还没有在等待队列中(思考一下进入等待队列的操作，先修改prev，再修改next)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果next已经有值了，那就说明一定在等待队列中了</span></span><br><span class="line">    <span class="comment">// (思考一下进入等待队列的操作,先修改prev，再修改next)</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 从后往前找一下，看是否存在于等待队列中</span></span><br><span class="line">    <span class="comment">// 同样需要结合入等待队列的操作分析</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>findNodeFromTail</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>checkInterruptWhileWaiting</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否在等待条件过程中发送中断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        <span class="comment">// 如果发生中断，看下是在哪个环节发送的中断</span></span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>transferAfterCancelledWait</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时已经唤醒了，修改一下状态</span></span><br><span class="line">    <span class="comment">// 此时有两种情况，一种是通过signal唤醒，那么状态会被signal修改,CAS失败</span></span><br><span class="line">    <span class="comment">// 如果CAS成功，意味着是非正常唤醒，有可能是中断，有可能是系统偶然唤醒</span></span><br><span class="line">    <span class="comment">// 但此时已有中断信号，说明只能是被中断了</span></span><br><span class="line">    <span class="comment">// 注意，此时CAS是成功的</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果被意外唤醒，那进入到等待队列排队吧</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明是正常唤醒，如果还没有在等待队列中，说明signal操作还没有完成</span></span><br><span class="line">    <span class="comment">// 自旋一下等待完成就可以了</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着回到最开始的<code>await</code>操作</p>
<blockquote>
<p>await</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 到这里就挂起了</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 到这里就被唤醒了</span></span><br><span class="line">        <span class="comment">//  1.通过signal唤醒</span></span><br><span class="line">        <span class="comment">//  2.中断唤醒</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前面分析到这里，checkInterruptWhileWaiting会返回三种值</span></span><br><span class="line">        <span class="comment">//  0，没有发生中断，那么就继续检查，排队吧</span></span><br><span class="line">        <span class="comment">//  如果不是0，说明发生了中断，那就该起来工作了</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，此时只是被唤醒，还没有拿到锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新排队等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 到这里说明获取锁，顺便清理一下取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果发生了中断，那就处理一下</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>reportInterruptAfterWait</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//  THROW_IE(-1)，transferAfterCancelledWait返回true则返回该值</span></span><br><span class="line">     <span class="comment">//    说明此时是被中断唤醒，那就需要抛出中断异常了</span></span><br><span class="line">     <span class="comment">//  REINTERRUPT(1)，通过signal正常唤醒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// await是可中断的</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送下中断信号就行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，等待条件的操作就结束了，重新梳理一下await操作的流程</p>
<ol>
<li>将自己添加到条件队列中</li>
<li>释放占据的锁<ol>
<li>释放失败说明是非法操作</li>
</ol>
</li>
<li>等待唤醒<ol>
<li>signal唤醒</li>
<li>中断唤醒</li>
</ol>
</li>
<li>唤醒之后，等待获取锁，获取之后<ol>
<li>接着挂起之前的流程</li>
<li>或者需要抛出异常，则直接抛出中断异常</li>
</ol>
</li>
</ol>
<h5 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h5><p>前面详细分析了等待条件发生的具体操作，接下来分析唤醒的具体操作</p>
<blockquote>
<p>signal</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是排它锁的持有者，则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="comment">// 唤醒下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doSignal</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// first即将唤醒，断开连接</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将找到的第一个合适的节点从条件队列移动到等待队列</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>transferForSignal</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将节点移动到等待队列，等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果修改状态失败，说明中途已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前状态已经取消排队，修改前节点表示自己需要被唤醒</span></span><br><span class="line">    <span class="comment">// 如果修改失败，那就说明前节点状态已经发送了变化，把自己也唤醒</span></span><br><span class="line">    <span class="comment">// 由于已经入队了，所以会去参与竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，唤醒的操作也是比较直观的，将第一个正常的节点移动到等待队列中等待唤醒，或者直接唤醒该节点(特殊情况)</p>
<blockquote>
<p>signalAll</p>
</blockquote>
<p><code>signal</code>操作只是唤醒其中的一个，如果需要唤醒多个，则通过<code>signalAll</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>doSignalAll</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有节点都尝试移动到等待队列，等待获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，唤醒的操作分析就结束了，稍微总结一下唤醒的过程</p>
<ol>
<li>将节点移动到等待队列</li>
<li>根据情况决定唤醒该节点还是结束本次唤醒操作(等待等待队列头节点唤醒即可)</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到了这里，基本上AQS的核心功能就分析完成了，当然，还有少部分的内容没有分析，这并非偷懒或者遗忘，而是这一部分的内容与后面的内容更加贴切，所以就将其放在后面分析了</p>
<p>在本文中，详细对AQS进行了详细的介绍，AQS是一个并发安全的同步器，通过AQS，可以简单快捷地实现一个并发安全的工具，当然，本文中只是提出这点，但并没有具体体现，在后面一篇文章中将结合已有基于AQS实现的同步在体现AQS的这个特点</p>
<p>在本文中，我们详细分析了AQS的获取锁的方式，包括</p>
<ul>
<li>独占锁<ul>
<li>不可中断</li>
<li>可中断</li>
</ul>
</li>
<li>共享锁<ul>
<li>不可中断</li>
<li>可中断</li>
</ul>
</li>
</ul>
<p>同时详细分析了其释放锁的具体操作以及条件队列的实现<code>ConditionObject</code></p>
<p>从分析中可以看出，AQS是基于链表来实现的，等待队列是基于双向链表，而条件队列是基于单向链表。如果获取不到锁或者条件不满足，则将其放到对应的队列尾部，等待唤醒，条件队列的节点唤醒之后，会将自己从条件队列移动到等待队列，等待获取锁</p>
<p>通过对AQS的分析，可以更好地理解一些并发工具的特性，在使用这些工具的时候能让我们更加清楚这些工具的注意事项</p>
<p>好了，到这里，对AQS的分析就告一段落了，后面将详细分析基于AQS实现的几个同步工具，Let’s keep going on.</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>AQS之AQS分析</p><p><a href="https://www.xuhuanfeng.cn/2019/11/20/AQS之AQS分析/">https://www.xuhuanfeng.cn/2019/11/20/AQS之AQS分析/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>大黄蜂</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-11-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-04-28</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/AQS/">AQS</a></div><div class="sharethis-inline-share-buttons"></div><script src="http://www.xuhuanfeng.cn/" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/11/21/axios%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">axios导出文件使用总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/10/19/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"><span class="level-item">Redis分布式锁使用总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/me.jpg" alt="大黄蜂"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">大黄蜂</p><p class="is-size-6 is-block">曾经沧海难为水，除却巫山不是云</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广东，深圳</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">33</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-28T07:00:18.000Z">2021-04-28</time></p><p class="title"><a href="/2021/04/28/%E9%A9%BE%E7%85%A7%E8%80%83%E5%8F%96%E6%8C%87%E5%8D%97/">驾照考取指南</a></p><p class="categories"><a href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a> / <a href="/categories/%E6%9D%82%E8%B0%88/%E7%94%9F%E6%B4%BB/">生活</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-28T08:27:12.000Z">2020-12-28</time></p><p class="title"><a href="/2020/12/28/Elasticsearch-Bulk-API%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Elasticsearch Bulk API学习笔记</a></p><p class="categories"><a href="/categories/Elasticsearch/">Elasticsearch</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-17T02:15:30.000Z">2020-12-17</time></p><p class="title"><a href="/2020/12/17/%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">跳跃表学习笔记</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Collections/">Collections</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-11T02:44:44.000Z">2020-12-11</time></p><p class="title"><a href="/2020/12/11/Java%E5%AE%B9%E5%99%A8%E4%B9%8BMap-JDK1-6/">Java容器之Map(JDK1.6)</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Collections/">Collections</a> / <a href="/categories/Java/Collections/Map/">Map</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-06T01:24:35.000Z">2020-12-06</time></p><p class="title"><a href="/2020/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">红黑树学习笔记</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/Collections/">Collections</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://donespeak.gitlab.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">DoneSpeak</span></span><span class="level-right"><span class="level-item tag">donespeak.gitlab.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Elasticsearch/"><span class="level-start"><span class="level-item">Elasticsearch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Collections/"><span class="level-start"><span class="level-item">Collections</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Collections/Map/"><span class="level-start"><span class="level-item">Map</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/Concurrent/"><span class="level-start"><span class="level-item">Concurrent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%B9%E5%99%A8/"><span class="level-start"><span class="level-item">容器</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">生活</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AQS/"><span class="tag">AQS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Atomic/"><span class="tag">Atomic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bulk/"><span class="tag">Bulk</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CAS/"><span class="tag">CAS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Collection/"><span class="tag">Collection</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Concurrent/"><span class="tag">Concurrent</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ConcurrentHashMap/"><span class="tag">ConcurrentHashMap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CountdownLatch/"><span class="tag">CountdownLatch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CyclicBarrier/"><span class="tag">CyclicBarrier</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Elasticsearch/"><span class="tag">Elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HashMap/"><span class="tag">HashMap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedHashMap/"><span class="tag">LinkedHashMap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LockSupport/"><span class="tag">LockSupport</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Map/"><span class="tag">Map</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paxos/"><span class="tag">Paxos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReentrantLock/"><span class="tag">ReentrantLock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SPI/"><span class="tag">SPI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Semaphore/"><span class="tag">Semaphore</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring-Starter/"><span class="tag">Spring Starter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TimeUnit/"><span class="tag">TimeUnit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TreeMap/"><span class="tag">TreeMap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/axios/"><span class="tag">axios</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"><span class="tag">分布式一致性</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><span class="tag">分布式锁</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"><span class="tag">红黑树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"><span class="tag">自动装配</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"><span class="tag">跳跃表</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A9%BE%E7%85%A7/"><span class="tag">驾照</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">凌风的小窝</a><p class="is-size-7"><span>&copy; 2021 大黄蜂</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>